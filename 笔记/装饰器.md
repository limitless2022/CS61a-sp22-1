### @classmethod 装饰器

- **classmethod 修饰符用来标记一个方法为类方法**，
- 类方法的第一个参数是类对象参数，在方法被调用的时候自动将类对象传入，参数名称约定为cls
- 类方法可被类对象调用(如` Rabbit.rabbit_class)`，也可以被实例对象调用(`rabbit.rabbit_class`)
- 类被继承后，子类也可以调用父类的类方法，但是第一个参数传入的是子类的类对象(类名)

```python
class Rabbit():
   
    def __init__():
        self.name='liu'
        self.age=20
    
    @classmethod
    def rabbit_class(cls, name, age):
        print("person name is:"+name)
        print("person age is:"+age)
    
    #不用@classmethod标记的方法
    def rabbit(self,name,age):
        print("person name is:"+name)
        print("person age is:"+age)
        
    
rabbit = new Rabbit() 
Rabbit.rabbit_class
rabbit.rabbit_class

rabbit.rabbit
```



### **Trace装饰器**

> 在查看函数什么时候递归调用时很有用

```python
>>> def trace(fn):
        def wrapped(x):
            print('-> ', fn, '(', x, ')')
            return fn(x)
        return wrapped
    
>>> @trace 
    def triple(x):
        return 3 * x
```

函数triple被创建且名称triple绑定到用triple作为参数去调用函数trace 的返回值。 这个装饰器相当于：

```python
>>> def triple(x):
        return 3 * x
>>> triple = trace(triple) #只不过这个不能追踪递归
```

